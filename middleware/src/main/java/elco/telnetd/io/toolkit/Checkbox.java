/* Copyright (c) 2018, EL.CO. SRL.  All rights reserved.
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 * Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following
 * disclaimer in the documentation and/or other materials provided
 * with the distribution.
 * THIS SOFTWARE IS PROVIDED FREE OF CHARGE AND ON AN "AS IS" BASIS,
 * WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED INCLUDING
 * WITHOUT LIMITATION THE WARRANTIES THAT IT IS FREE OF DEFECTS, MERCHANTABLE,
 * FIT FOR A PARTICULAR PURPOSE OR NON-INFRINGING. THE ENTIRE RISK
 * AS TO THE QUALITY AND PERFORMANCE OF THE SOFTWARE IS WITH YOU.
 * SHOULD THE SOFTWARE PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL
 * NECESSARY SERVICING, REPAIR, OR CORRECTION.
 * IN NO EVENT SHALL ELCO SRL BE LIABLE TO YOU FOR DAMAGES, INCLUDING
 * ANY GENERAL, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING
 * OUT OF THE USE OR INABILITY TO USE THE SOFTWARE (INCLUDING, BUT NOT
 * LIMITED TO, LOSS OF DATA, DATA BEING RENDERED INACCURATE, LOSS OF
 * BUSINESS PROFITS, LOSS OF BUSINESS INFORMATION, BUSINESS INTERRUPTIONS,
 * LOSS SUSTAINED BY YOU OR THIRD PARTIES, OR A FAILURE OF THE SOFTWARE
 * TO OPERATE WITH ANY OTHER SOFTWARE) EVEN IF ELCO SRL HAS BEEN ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGES.
 */
package elco.telnetd.io.toolkit;import java.io.IOException;import elco.telnetd.io.BasicTerminalIO;/** * Class that implements a Checkbox component. */public class Checkbox extends ActiveComponent {	// Members	private String mText = "";	private boolean mSelected = false;	private String mMark;	private String mLeftBracket;	private String mRightBracket;	public static final int SMALL_CHECKMARK = 10;	public static final int LARGE_CHECKMARK = 11;	public static final int SQUARED_BOXSTYLE = 1;	public static final int ROUND_BOXSTYLE = 2;	public static final int EDGED_BOXSTYLE = 3;	private static final int SPACE = 32;	/**	 * Constructs a checkbox instance.	 */	public Checkbox(BasicTerminalIO io, String name) {		super(io, name);		setBoxStyle(SQUARED_BOXSTYLE);		setMarkStyle(LARGE_CHECKMARK);	}// constructor	/**	 * Method to set the checkbox`s state.	 *	 * @param b	 *            boolean that represents the state (true equals selected, false equals not selected).	 */	public void setSelected(boolean b) throws IOException {		mSelected = b;		drawMark();	}// setSelected	/**	 * Accessor method for the state of the checkbox instance.	 *	 * @return boolean that represents the state (true equals selected, false equals not selected).	 */	public boolean isSelected() {		return mSelected;	}// isSelected	/**	 * Mutator method for the text property of the checkbox item. This text will be placed like a label, naturally you can leave this text empty and place a label if used in a	 * form.	 *	 * @param str	 *            String that represents the text that will be displayed right of the checkbox.	 */	public void setText(String str) {		mText = str;	}// setText	/**	 * Mutator method for the boxstyle property of the checkbox. The *_BOXSTYLE constants should be passed as parameter.	 *	 * @param style	 *            int that represents one of the defined constants for boxstyles.	 */	public void setBoxStyle(int style) {		switch (style) {		case ROUND_BOXSTYLE:			mLeftBracket = "(";			mRightBracket = ")";			break;		case EDGED_BOXSTYLE:			mLeftBracket = "<";			mRightBracket = ">";			break;		case SQUARED_BOXSTYLE:		default:			mLeftBracket = "[";			mRightBracket = "]";		}	}// setBoxStyle	/**	 * Mutator method for the markstyle property of the checkbox. The *_CHECKMARK constants should be passed as parameter.	 *	 * @param style	 *            int that represents one of the defined constants for checkmarks.	 */	public void setMarkStyle(int style) {		switch (style) {		case SMALL_CHECKMARK:			mMark = "x";			break;		case LARGE_CHECKMARK:		default:			mMark = "X";		}	}// setMarkStyle	/**	 * Method that will make the checkbox active, reading and processing input.	 */	@Override	public void run() throws IOException {		int in;		draw();		mIO.flush();		do {			// get next key			in = mIO.read();			switch (in) {			case SPACE:				setSelected(!mSelected); // toggle actual state, will redraw mark				break;			case BasicTerminalIO.TABULATOR:			case BasicTerminalIO.ENTER:				in = -1;				break;			default:				mIO.bell();			}			mIO.flush();		} while (in != -1);	}// run	/**	 * Method that draws the component.	 */	@Override	public void draw() throws IOException {		StringBuilder sbuf = new StringBuilder();		sbuf.append(" "); // 1/1		sbuf.append(mLeftBracket); // 1/2		if (mSelected) {			sbuf.append(mMark); // 1/3		} else {			sbuf.append(" ");		}		sbuf.append(mRightBracket); // 1/4		sbuf.append(" "); // 1/5		sbuf.append(mText); // 1/5+myText.length		if (mPosition != null) {			mIO.setCursor(mPosition.getRow(), mPosition.getColumn());		}		mIO.write(sbuf.toString());		mIO.moveLeft(3 + mText.length()); // thats the mark position		mIO.flush();	}// draw	private void drawMark() throws IOException {		if (mPosition != null) {			mIO.storeCursor();			mIO.setCursor(mPosition.getRow(), mPosition.getColumn());			mIO.moveRight(2);		}		if (mSelected) {			mIO.write(mMark);		} else {			mIO.write(" ");		}		if (mPosition == null) {			mIO.moveLeft(1); // back to mark position		} else {			mIO.restoreCursor();		}		mIO.flush();	}}