/* Copyright (c) 2018, EL.CO. SRL.  All rights reserved.
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 * Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following
 * disclaimer in the documentation and/or other materials provided
 * with the distribution.
 * THIS SOFTWARE IS PROVIDED FREE OF CHARGE AND ON AN "AS IS" BASIS,
 * WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED INCLUDING
 * WITHOUT LIMITATION THE WARRANTIES THAT IT IS FREE OF DEFECTS, MERCHANTABLE,
 * FIT FOR A PARTICULAR PURPOSE OR NON-INFRINGING. THE ENTIRE RISK
 * AS TO THE QUALITY AND PERFORMANCE OF THE SOFTWARE IS WITH YOU.
 * SHOULD THE SOFTWARE PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL
 * NECESSARY SERVICING, REPAIR, OR CORRECTION.
 * IN NO EVENT SHALL ELCO SRL BE LIABLE TO YOU FOR DAMAGES, INCLUDING
 * ANY GENERAL, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING
 * OUT OF THE USE OR INABILITY TO USE THE SOFTWARE (INCLUDING, BUT NOT
 * LIMITED TO, LOSS OF DATA, DATA BEING RENDERED INACCURATE, LOSS OF
 * BUSINESS PROFITS, LOSS OF BUSINESS INFORMATION, BUSINESS INTERRUPTIONS,
 * LOSS SUSTAINED BY YOU OR THIRD PARTIES, OR A FAILURE OF THE SOFTWARE
 * TO OPERATE WITH ANY OTHER SOFTWARE) EVEN IF ELCO SRL HAS BEEN ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGES.
 */
package elco.telnetd.io.toolkit;import java.io.IOException;import elco.telnetd.io.BasicTerminalIO;/** * Class that implements an Editfield. */public class Editfield extends ActiveComponent {	// Associations	private InputFilter mInputFilter = null;	private InputValidator mInputValidator = null;	// Aggregations (inner class!)	private final Buffer mBuffer;	// Members	private int mCursor = 0;	private boolean mInsertMode = true;	private int mLastSize = 0;	private boolean mPasswordField = false;	private boolean mJustBackspace;	/**	 * Constructs an Editfield.	 */	public Editfield(BasicTerminalIO io, String name, int length) {		// init superclass		super(io, name);		// init class params		mBuffer = new Buffer(length);		setDimension(new Dimension(length, 1));		mCursor = 0;		mInsertMode = true;	}// constructor	/**	 * Accessor method for field length.	 *	 * @return int that represents length of editfield.	 */	public int getLength() {		return mDim.getWidth();	}// getLength	/**	 * Accessor method for field buffer size.	 *	 * @return int that represents the number of chars in the fields buffer.	 */	public int getSize() {		return mBuffer.size();	}// getSize	public String getValue() {		return mBuffer.toString();	}// getValue	public void setValue(String str) throws BufferOverflowException, IOException {		clear();		append(str);	}// setValue	public void clear() throws IOException {		positionCursorAtBegin();		for (int i = 0; i < mBuffer.size(); i++) {			mIO.write(' ');		}		positionCursorAtBegin();		mBuffer.clear();		mCursor = 0;		mLastSize = 0;		mIO.flush();	}// clear	public char getCharAt(int pos) {		return mBuffer.getCharAt(pos);	}// getCharAt	public void setCharAt(int pos, char ch) throws IOException {		// buffer		mBuffer.setCharAt(pos, ch);		// cursor		// implements overwrite mode no change		// screen		draw();	}// setCharAt	public void insertCharAt(int pos, char ch) throws BufferOverflowException, IOException {		storeSize();		// buffer		mBuffer.ensureSpace(1);		mBuffer.insertCharAt(pos, ch);		// cursor adjustment (so that it stays in "same" pos)		if (mCursor >= pos) {			moveRight();		}		// screen		draw();	}// insertCharAt	public void removeCharAt(int pos) throws IOException {		storeSize();		// buffer		mBuffer.removeCharAt(pos);		// cursor adjustment		if (mCursor > pos) {			moveLeft();		}		// screen		draw();	}// removeChatAt	public void insertStringAt(int pos, String str) throws BufferOverflowException, IOException {		storeSize();		// buffer		mBuffer.ensureSpace(str.length());		for (int i = 0; i < str.length(); i++) {			mBuffer.insertCharAt(pos, str.charAt(i));			// Cursor			mCursor++;		}		// screen		draw();	}// insertStringAt	public void append(char ch) throws BufferOverflowException, IOException {		storeSize();		// buffer		mBuffer.ensureSpace(1);		mBuffer.append(ch);		// cursor		mCursor++;		// screen		if (!mPasswordField) {			mIO.write(ch);		} else {			mIO.write('.');		}	}// append(char)	public void append(String str) throws BufferOverflowException, IOException {		storeSize();		// buffer		mBuffer.ensureSpace(str.length());		for (int i = 0; i < str.length(); i++) {			mBuffer.append(str.charAt(i));			// Cursor			mCursor++;		}		// screen		if (!mPasswordField) {			mIO.write(str);		} else {			StringBuilder sbuf = new StringBuilder();			for (int n = 0; n < str.length(); n++) {				sbuf.append('.');			}			mIO.write(sbuf.toString());		}	}// append(String)	public int getCursorPosition() {		return mCursor;	}// getCursorPosition	public boolean isJustBackspace() {		return mJustBackspace;	}// isJustBackspace	public void setJustBackspace(boolean b) {		mJustBackspace = true;	}// setJustBackspace	/**	 * @param filter	 *            Object instance that implements the InputFilter interface.	 */	public void registerInputFilter(InputFilter filter) {		mInputFilter = filter;	}// registerInputFilter	/**	 * @param validator	 *            Object instance that implements the InputValidator interface.	 */	public void registerInputValidator(InputValidator validator) {		mInputValidator = validator;	}// registerInputValidator	public boolean isInInsertMode() {		return mInsertMode;	}// isInInsertMode	public void setInsertMode(boolean b) {		mInsertMode = b;	}// setInsertMode	public boolean isPasswordField() {		return mPasswordField;	}// isPasswordField	public void setPasswordField(boolean b) {		mPasswordField = b;	}// setPasswordField	/**	 * Method that will be reading and processing input.	 */	@Override	public void run() throws IOException {		int in;		draw();		mIO.flush();		do {			// get next key			in = mIO.read();			// Just backspace mode, convert deletes to backspace			if (mJustBackspace && in == BasicTerminalIO.DELETE) {				in = BasicTerminalIO.BACKSPACE;			}			// send it through the filter if one is set			if (mInputFilter != null) {				in = mInputFilter.filterInput(in);			}			switch (in) {			case -1:				mBuffer.clear();				break;			case InputFilter.INPUT_HANDLED:				continue;			case InputFilter.INPUT_INVALID:				mIO.bell();				break;			case BasicTerminalIO.LEFT:				moveLeft();				break;			case BasicTerminalIO.RIGHT:				moveRight();				break;			case BasicTerminalIO.UP:			case BasicTerminalIO.DOWN:				mIO.bell();				break;			case BasicTerminalIO.ENTER:				if (mInputValidator != null) {					if (mInputValidator.validate(mBuffer.toString())) {						in = -1;					} else {						mIO.bell();					}				} else {					in = -1;				}				break;			case BasicTerminalIO.BACKSPACE:				try {					removeCharAt(mCursor - 1);				} catch (IndexOutOfBoundsException ioobex) {					mIO.bell();				}				break;			case BasicTerminalIO.DELETE:				try {					removeCharAt(mCursor);				} catch (IndexOutOfBoundsException ioobex) {					mIO.bell();				}				break;			case BasicTerminalIO.TABULATOR:				in = -1;				break;			default:				handleCharInput(in);			}			mIO.flush();		} while (in != -1);	}// run	@Override	public void draw() throws IOException {		int diff = mLastSize - mBuffer.size();		String output = mBuffer.toString();		if (mPasswordField) {			StringBuilder stbuf = new StringBuilder();			for (int n = 0; n < output.length(); n++) {				stbuf.append('.');			}			output = stbuf.toString();		}		if (diff > 0) {			StringBuilder sbuf = new StringBuilder();			sbuf.append(output);			for (int i = 0; i < diff; i++) {				sbuf.append(" ");			}			output = sbuf.toString();		}		if (mPosition != null) {			mIO.setCursor(mPosition.getRow(), mPosition.getColumn());		} else {			mIO.moveLeft(mCursor);		}		mIO.write(output);		// adjust screen cursor hmm		if (mCursor < output.length()) {			mIO.moveLeft(output.length() - mCursor);		}	}// draw	private void moveRight() throws IOException {		// cursor		if (mCursor < mBuffer.size()) {			mCursor++;			// screen			mIO.moveRight(1);		} else {			mIO.bell();		}	}// moveRight	private void moveLeft() throws IOException {		// cursor		if (mCursor > 0) {			mCursor--;			// screen			mIO.moveLeft(1);		} else {			mIO.bell();		}	}// moveLeft	private void positionCursorAtBegin() throws IOException {		// 1. position cursor at first char		if (mPosition == null) {			mIO.moveLeft(mCursor);		} else {			mIO.setCursor(mPosition.getRow(), mPosition.getColumn());		}	}// positionCursoratBegin	private boolean isCursorAtEnd() {		return (mCursor == mBuffer.size());	}// isCursorAtEnd	private void handleCharInput(int ch) throws IOException {		if (isCursorAtEnd()) {			try {				// Field				append((char) ch);			} catch (BufferOverflowException bex) {				mIO.bell();			}		} else {			if (isInInsertMode()) {				try {					// Field					insertCharAt(mCursor, (char) ch);				} catch (BufferOverflowException bex) {					mIO.bell();				}			} else {				try {					// Field					setCharAt(mCursor, (char) ch);				} catch (IndexOutOfBoundsException bex) {					mIO.bell();				}			}		}	}// handleCharInput	private void storeSize() {		mLastSize = mBuffer.size();	}// storeSize	// inner class Buffer	class Buffer extends CharBuffer {		public Buffer(int size) {			super(size);		}// constructor	}// class Buffer}